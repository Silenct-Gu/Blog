---
title: .Net体系结构
categories:
    - C#
---

## .NET

1.1C#与.NET 的关系整本书都将强调，C#i 吾言不能孤立地使用，而必须和.NET Framework —起考虑。C#编译器专
门用于.NET,这表示用 C#编写的所有代码总是使用.NET Framework 运行。对于言来说，可以
得出两个重要的结论：
(1)C#的体系结构和方法论反映了.NET 基础方法论。
(2)在许多情况下，C#的特定语言功能取决于.NET 的功能，或依赖于.NET 基类。
由于这种依赖性，在开始编写 C#程序前，了解.NET 的体系结构和方法论就非常重要，这就是
本章的目标。
C#是一种相当新的编程语言，C#的重要性体现在以下两个方面：
•C#是专门为与 Microsoft 的.NET Framework 一起使用而设计的(.NET Framework 是一个功能非常丰富的框架、平台，可开发、部署和执行分布式应用程序)。
•它是一种基于现代面向对象设计方法的语言，在设计它吋.Microsoft 还吸取了其他所有类
似语言的经验，这些语言是近 20 年来面向对象规则得到广泛应用后才开发出来的。
C#就其本身而言只是一种语言，尽管它是用于生成面向.NET 环境的代码，但它本身不是.NET 的一部分。.NET 支持的一些特性，C#并不支持。而 C#语言支持的另一些特性，.NET 却不支持(如
运算符重载)！

第 1 章.NET 体系结构
但是，因为 C#i§言和.NET •起使用，所以如果要使用 C#商效地开发应用程序，理解 Framework
就非常重要.所以本章将介绍.NET 的内涵。
1.2 公共语言运行库
■NET Framework 的核心是其运行库执行环境，称为公共语言运行库（CLR）或.NET 运行库。通
常将在 CLR 控制下运行的代码称为托管代码（managed code）。
们是.在 CLR 执行编写好的源代码（使用 C#或其他语言编写的代码）之前，需要编译它们。在.NET
中|编译分为两个阶段：
（1） 将源代码编译为 Microsoft 中间语言（1L）。
（2） CLR 把 IL 编译为平台专用的代码。
这个两阶段的编译过程非常因为 Microsoft 中间语言是提供.NET 的许多优点的关键。
Microsoft 中间语言与 Java 字节码共享•种理念：它们都是低级语言，语法很简单（使用数字代
码，而不是文本代码），可以非常快速地转换为本地机器码。对于代码，这种精心设计的通用语法有
很重嬰的优点:平台无关性、提高性能和语言的互操作性。
1.2.1 平台无关性
打先.这怠味卷包含字节码指令的同•文件可以放在任一平台中，运行吋，编译过程的最后阶
段可以很轻松地完成，这样代码就可以运行在特定的平台 L。换言之，编译为中间语言就可以获
衍.NET 甲台无关性，这与编译为 Java 字节码就会得到 Java 平台无关性是一样的。
注怠.NET 的平台无关性目前只是停留在现论范畴，因为在编写本书吋，.NET 的完粮实现只能
/I] J- Windows 平台。不过，现作己经釘了.NET 的•个部分跨平台实现（参见 Mono 项目，它用于实
现.NET 的开放源代糾，参见 http://www.go-mono.com/）。通过 Xamarin（www.xamarin.com）中的工具
和痄也可以在 iPhone 和 Android 没谷 I:使用 C#。
1.2.2 提高性能
前而对 IL 和 Java 做了比较，实阿 I：, 1L 比 Java 字节码的作用还耍大。IL 总是即吋编泽的（称为
J1T 编译＞，而 Java 字节码常常是解杼性的。Java 的•个缺点是，在运行应用程序吋，把 Java 字节码
转换为内部可执行代码的过程会导致性能的损失（但在最近，Java 在某舒台上能进行 JIT 编译）。
JIT 编 if 器把悄个沌川祝序•次编译完（这样会有很 K 的动吋间），而是只编译它调用的
那部分代码（这是其名称山来）。代码编译过-次后，得到的木地可执行程序就存储起来，直到退出
该 hV 川 W 序力土，这样在 K 次运行这部分代 fi1 樹.就不耑嬰取新编译了。Microsoft 汄为这个过程要
比•开始就编译粮个应用程序代码的效率商得多，因为任何应用程序的大部分代码实际上并不是在
每次运行期 1 川都执行。使川 JIT 编译器.从来都不会编汴这种代码。
这解杼 f 为什么托竹 IL 代码几乎和木地机器代奶的执行速度•样快.们是并没存说明为什么
Microsoft 认为这会提商性能。獅醒编译过程的煨后-部分是在运行时进行的，J1T 编译器确切
地知道运行 A:什么类型的处现器 I'-.可以利用该处理器提供的任何特性姗定的机器代码指令
来优化艰后的可执行代码。
传统的编译器会优化代码.ff!它们的优化过観独'■/：f 运行代码的特定处理器的。这是因为传

第 I 部分 C#语言
统的编译器是在发布软件之前编译为本地机器可执行的代码。即编译器不知道运行代码的处理器的
类型，例如该处理器是兼容 x86 的处理器还是 Alpha 处理器，这超出了基本操作的范围。
1.2.3 语言的互操作性
使用 IL 不仅支持平台无关性，还支持语言的互操作性。简而言之，就是能将任何一种语言编译
为中间语言，编译为中间语言的代码可以与从其他语言编译过来的代码进行交互操作。
那么除了 C#之外，还有什么语言可以通过.NET 进行交互操作呢？下面就简要讨论其他常见语
言如何与.NET 交互操作。
1.Visual Basic 2013
Basic 6 在升级到 Visual Basic .NET 2002 时，经历了一番脱胎换骨的变化，才集成到.NET
Framewoik 的第 1 版中。Visual Basic 语言对 Wsual Basic 6 进行了很大的演化，也就是说，Visual Basic
6 并不适合运行.NET 程序。例如，COM（Component Object Model,组件对象模型）的高度集成，
并且只把事件处理程序作为源代码显示给开发人员，大多数代码隐藏不能用作源代码。另外，它不
支持继承的实现’ Visual Basic 6 使用的标准数据类型也与.NET 不兼容。
Visual Basic 6 在 2002 年升级为 Visual Basic .NET,对 Visual Basic 进行的改变非常大，完全可
以把 Visual Basic .NET 当成一种新语言。
从那之后，Visual Basic 经历了许多语言改进，与 C#一样多。Visual Basic 和 C#在功能上非常类
似，因为它们都由 Microsoft 中同一个产品团队开发。随着时间的推移，Visual Basic 具备了曾经只
能用于 C#的功能，也具备丁曾经只能用于 Visual Basic 的功能，目前 Visual Basic 和 C#之间的区
别很小，主要是使用花括号还是 END 语句的个人喜好问题，
2.Visual C++2013
Visual C++ 6 有许多 Microsoft 对 Windows 的特定扩展，Visual C++ .NET 又新増了更多的扩展
内容来支持.NETFramework。现有的 C++源代码会继续编译为本地可执行代码，而不会有修改，但
它会独立于.NET 运行库运行。如果让 C++ffi 码在.NET Framework 中运行，就可以在代码的开头添
加下述命令：
fusing
还可以把标记/clr 传递给编译器，这样编译器假定要编译托管代码，因此会生成中间语言，而不
是本地机器码。C++的一个有趣的问题是在编译成托管代码时，编译器可以生成包含内嵌本地可执
行程序的 IL。这表示在 C++代码中可以把托管类型和非托管类型合并起来，因此托管 C++代码：
classMyClass
定义了一个普通的 C++类，而代码：
ref class MyClass
{
生成了一个托管类，就好像使用 C#或 Visual Basic 2013 编写类一样。实际上，托管 C++代码比

第 1 章.NET 体系结构
C#代码更优越的-点是可以在托管 C++代码中调用非托管 C++类，而不必采用 COM 互操作功能。
如果在托管类型上试图使 ffl.NET 不支持的特性(例如，模板或类的多继承编译器就会出现一
个错误。另外.在使用托管类吋.还需要使用非标准 C++功能，
编写使用.NET 的 C++程序会得到几种不同的互操作场景。使用编译器设置/clr 启用公共语言运
行库支持时，就可以完全混合所有的本地和托管 C++功能。其他选项(如/clrsafe 和/clrpure)可以限制
CH•指针的使用，从而像使用 C#和 Visual Basic 那样编写安全的代码。
Visual C++ 2013 允许为 Windows 8.1 的 Windows Runtime(WinRT)创建程序。在这样的程序中，
C++不使用托管代码.而是本地访问 WinRT。
3.Visual F#
F#是 个强类型化的函数编程语言，这种语言在 Visual Studio 中得到了强力支持。
作为•种函数编程语言,F#表面上与 C#完全不同。例如，声明一个带成员 FirstName 和 LastName
的 Person 类型，如下所示：
module Personsample
type Person(firstName : string, lastName : string)=
member this.FirstName = firstName
member this.LastName = lastName
使用 Person 类型，就要利用 let 关键字。printfo 会把结果写入控制台：
open PersonSample
()
let main argv =
let p = Person("Sebastian", "Vettel")
let first = p.firstName
let last = p.lastName
printfn "%s %s" first last
0 // return an integer exit code
F#可以使用 C#创建的所有类型，反之亦然。F#的优点是，这是一种函数语言，而不是面向对
象的，这有助于编写复杂的算法，例如财务和科学应用程序。
4.COM 和 COM+
从技术上讲，COM 和 COM+并不是面向.NET 的技术，因为基于它们的组件不能编译为 IL(但
如果原来的 COM 组件是用 CW 编写的，那么使用托管 C++在某种程度上可以这么做)。但是 I COM+
仍然足•个蜇要工具.因为它包含•辟.NET 不具谷的特性。另外，COM 组件仍可以使用——.NET
比成了 COM 的操作性，从而使托宵代码可以调用 COM 组件，COM 组件也可以调用托管代码(见
第 23 兑)。般情况下，把新组件编写为.NET 组件，大多是为了方便，因为这样可以利用.NET 基
类和托讶代码的其他优点。
5.Windows 运行库
Windows 8 提供 f 种 Windows Store 应用可以使用的新运行厍，这个运行库的某些部分也可以

第 I 部分 C#语言
由桌面应用程序使用。这个运行库可在 Visual Basic、C#、C++和 JavaScript 中使用，用在不同的环
境中时，它会发生相应的变化。例如，在 C#中使用时’它看起来就像.NET Framework 中的类；在
JavaScript 中使用时，它看起来就像 JavaScript 开发人员所惯用的 JavaScript 库；而在 C++中使用时，
它又像是一个 C++标准库，这种多样性是通过使用语言投影实现的，第 31 章将讨论 Windows 运行
库以及在 C#中如何使用它。
1.3 中间语言
如前所述，Microsoft 中间语言显然在.NET Framework 中起着非常重要的作用。现在应详细讨论
一下 IL 的主要特征，因为面向.NET 的所有语言在逻辑上都需要支持 IL 的主要特征。
下面就是中间语言的主要特征：
•面向对象和使用接口
•值类型和引用类型之间的显著差异
•强数据类型化
•使用异常来处理错误
•使用特性(attribute)
下面详细讨论这些特征。
1.3.1 面向对象和接口的支持
.NET 的语言无关性还有一些实际的限制。中间语言在设计时就打算实现某些特殊的编程方法，
这表示面向它的语言必须与该编程方法兼容，Microsoft 为 IL 选择的特定道路是传统的面向对象的
编程，带有类的单一继承性。
除了传统的面向对象编程外，中间语言还引入了接口的概念，在带有 COM 的 Windows 下第一
次实现了接口。用.NET 建立的接 U 与 COM 接 U 不同，它们不：要支持任何 COM 基础设施，例如,
它们不是派生自 IUnknown’也没有对应的 GUKX 但它们与 COM 接口共享下述理念：提快-个契约，
实现给定接口的类必须提供该接口指定的方法和属性的实现。
前面介绍丁使用,NET 意味着要编译为中间语言，即需要使用传统的面向对象的方法来编程。但
这并不能提供语言的互操作性。毕竟，C++和 Java 都使用相同的面向对象的范例，但它们仍不是可
交互操作的语宫.下面需要详细探讨• •下语言互操作性的概念。
首先，需要了解一下语言互操作性的准确含义。
毕竟，COM 允许以不同语言编写的组件一起工作，即可以调用彼此的方法。这就足够了吗？
COM 是一个二进制标准，允许组件实例化其他组件，调用它们的方法或属性，而无须考虑编写相
关组件的语言。但为了实现这个功能，每个对象都必须通过 COM 运行库来实例化，通过接口来访
问。根据相关组件的线程模型，需要在不同线程的内存空间和运行组件之间编组数据.这可能造成
很大的性能损失。在极端情况下，组件保存为可执行文件，而不是 DLL 文件，还必须创建单独的进
程来运行它们。重要的是组件仅能通过 COM 运行库与其他组件通信，使用不同语言的组件无法通
过 COM 直接彼此通信，或者创建彼此的实例——系统总将 COM 作为中间件，不仅如此，COM 体
系结构还不允许利用继承实现，即它丧失了面向对象编程的许多优势，
6

第 1 章.NET 体系结构
一个相关的问题是，在调试吋，仍必须单独调试使用不同语言编写的组件。不可能在调试器上
交替调试不同语言的代码。语言互操作性的真正含义是用一种语言编写的类应能直接与用另一种语
言编写的类通信。特别是：
•用一种语言编写的类应能继承用另一种语言编写的类。
•-个类应能包含另一个类的实例，而不管两个类是使用什么语言编写的。
• 一个对象应能直接调用用其他语言编写的另一个对象的方法。
•对象（或对象的引用）应能在方法之间传递。
•在不同的语言之间调用方法时，应能在调试器中交替调试这些方法调用，即调试不同语言
编写的源代码。
这是一个雄心勃勃的目标，但令人惊讶的是，.NET 和中间语言已经实现了这个目标。在调试器
上交替调试方法时| Visual Studio IDE（Intergrated Development Environment,集成开发环境）提供了这
样的工具（不是 CLR 提供的）。
1.3.2 不同的值类型和引用类型
与其他编程语言一样，中间语言提供了许多预定义的基本数据类型。它的-•个特性是值类型和
引用类型之间有明显的区别。对于值类型（value type）,变量直接存储其数据，而对于引用类型
（reference type）,变量仅存储地址.对应的数据可以在该地址中找到。
在 C++中，使用引用类型类似于通过指针来访问变量，而在 Visual Basic 中，与引用类型最相
似的是对象，Visual Basic 6 总是通过引用来访问对象。中间语言也有数据存储的规范：引用类型的
实例总是存储在一个名为“托管堆”的内存区域中，值类型一般存储在堆栈中（但如果值类型在引用
类型中声明为字段，它们就内联存储在堆中）。第 2 章讨论堆栈和托管堆，及其工作原理。
1-3.3 强数据类型化
中间语言的•个重要方面是它基于强数据类型化。所有的变量都清晰地标记为属于某个特定数
据类型（在中间语言中没有 Visual Basic 和脚本语言中的 Variant 数据类型）。特别是中间语言-•般不允
许对模糊的数据类型执行任何操作。
例如，Visual Basic 6 幵发人员习惯于传递变量，而无须考虑它们的类型，因为 Visual Basic 6 会
fl 动进行所需的类型转换。C++开发人员习惯于在不同类型之间转换指针类型。执行这类操作将极
大地提卨性能.但破坏了类型的安全性。因此，在某婆编译为托管代码的语言中，这类操作只能在
特殊情况下进行。确实，指针（相对于引用）只能在标记了的（2 袱码块中使用，但在 Visual Basic 中
不 fig 使川（似•般在托管 C++中允许使用）。在代码中使用指针会立即导致 CLR 执行的内存类型安全
性检查失败。注意， 些 W.NET 兼容的语言，例如 Visual Basic 2010,在类型化方面的要求仍比较
宽松，侃这是可以的，因为编译器在后台确保在牛.成的 IL 上强制类型安全。
尽管强迫实现类型的安全性似乎会降低性能，但在许多情况下.我们从.NET 提供的、依赖于类
型安全的服务中获得的好处更多。这些服务包括：
•语言的丸操作性
•垃圾收集
•安全性
•应用程序域
7

第 1 部分 c«语言
下面讨论强数据类型 4^t.NET 的这些功能非常重要的原因。 1.语言互操作性中强数据类型化的重要性
如果类派生自其他类，或包含其他类的实例，它就需要知道其他类使用的所有数据类型，这就
是趣玫据类型化非常重要的原因。实际上，过去由于缺少用于指定这类信息的一致的系统，从而成
为语言继承和交互操作的真正障碍.这类信息并未在标准的可执行文件或 DLL 中出现。
假定将 Visual Basic 2013 类中的一个方法定义为返回一个 Integer——Visual Basic 2013 可以使用
的标准数据类型之但 C#没有该名称的数据类型。显然’只有编译器知道如何把 Visual Basic 2013
的 Integer 类型映射为 C#定义的某种己知类型，才可以从该类派生，使用这个方法，并在 CH 弋码中
使用返回的类型•这个问题在.NET 中是如何解决的？
通用类型系统(CTS)
此»^类型问题在.NET 中使用通用类型系统(CTS)得到了解决。CTS 定义了可以在中间语言中
使用的预定义数据类型，所有面向.NETFramcwork 的语言都可以生成最终基于这些类型的编译代码，
对于上面的例子，Visual Basic 2013 的 Integer 实际上是一个 32 位有符号的整数，它实际映射为
中间语言类型 Int32。因此在中间语言代码中就指定这种数据类型。C#编译器可以使用这种类型，
所以就不会有问题了。在源代码中,C#用关键字 int 来表示 Int32,所以编译器就认为 Visual Basic 2013
方法返回一个 int 类型的值。
CTS 不仅指定了基本数据类型，还定义了一个内容丰富的类型层次结构，其中包含设计合理的
位置，在这些位置上，代码允许定义它自己的类型。CTS 的层次结构反映 T 中间语言的单一继承的
面向对象方法，如图 1-1 所示，

囲 1-1
这里没有列出内置的所有值类型，因为第 3 章将详细介绍它们。在 C#中，编译器识别的每个预
定义类型都映射为一个 IL 内置类型.这与 Visual Basic 2013 -样。
公共语言规范(CLS)
公共语言规范(Common Language Specification, CLS)和通用类型系统一起确保语言的互操作性。

第 1 章.NET 体系结构
CLS 是一个最低标准集，所有面［nJ.NET 的编译器都必须支持它。因为 IL 是一种内涵非常丰富的语
言，大多数编译器的编写人员有可能把给定编译器的功能限制为只支持 IL 和 CTS 提供的一部分功
能。只要编译器支持己在 CLS 中定义的内容，这就很不错。
下面的一个例子是有关区分大小写字母的。IL 是区分大小写的语言。使用这些语言的开发人员
常常利用区分大小写所提供的灵活性来选择变量名。但 Visual Basic 2013 是不区分大小写的语言。
CLS 通过指定 CLS 兼容代码不使用任何只根据大小写来区分的名称，解决了这个问题。因此，Visual
Basic 2013 代码可以与 CLS 兼容代码一起使用。
这个例子说明了 CLS 的两种工作方式。
(1)各个编译器的功能不必强大到支持.NET 的所有功能，这将鼓励人们为其他面向.NET 的编
程语言开发编译器。
(2)如果限制类只能使用 CLS 兼容的特性，就要保证用其他兼容语言编写的代码可以使用这
个类。
这种方法的优点是使用 CLS 兼容特性的限制只适用于公共和受保护的类成员和公共类。在类的
私有实现方式中.可以编写非 CLS 代码，因为其他程序集(托管代码的单元，参见本章后面的内容)
中的代码不能访问这部分代码。
这里不深入讨论 CLS 规范。一般情况下，CLS 对 C#代码的影响不会太大，因为 C#中的非 CLS
兼容特性非常少。
(^\ 编写非 CLS 兼容代码是完全可以接受的。只是在编写了这种代码后，就不能保证
编译好的 IL 代码完全支持语言的互操作性。 2.垃圾回收
垃圾回收器(garbage collector)用来在.NET 中进行内存管理，特别是它可以恢复正在运行的应
用程序需要的内存。到目前为止，Windows 平台己经使用了两种技术来释放进程向系统动态请求
的内存：
•完全以手工方式使应用程序代码完成这些工作。
•让对象维护引用计数。
ik 应用程序代码负资释放内存是低级尚性能的语言使用的技术，例如 C++。这种技术很有效，
并 IL •般情况下可以让资源在不需嬰吋就释放，但其最大的缺点是频繁出现错误。请求内存的代码
还必须显式通知系统它什么吋候不再需嬰该内存。但这是很容易被遗漏的，从而导致内存泄漏。
尽管现代的开发环境提供了帮助检测内存泄瀨的工具，但它们很难跟跤错误，因为直到内存己
大珙泄漏，从而使 Windows 把绝为进程提供资源吋，它们才会发挥作用。到那个时候，由于对内存
的需求很大.会使粮个计箅机变得相当慢。
维护引用计数是 COM 对象采用的一种技术，其方法是每个 COM 组件都保留•个计数.记录
客户端目前对它的引用数。当这个计数下降到 0 吋，组件就会删除自己，并释放相关的内存和资源。
它带来的问题是仍笟嬰客户端通知组件它们己经完成了内存的使用。只要衍•个客户端没有这么做，
对象就仍驻留在内存中。在某些方面，这是比 C++内存泄漏更为严霜的问题.因为 COM 对象可能
存在于它自己的进程中，从来不会被系统删除(在 O+内存泄漏问题上，系统至少可以在进程中断吋
9

第 I 部分 C#语言
释放所有的内存）。
.NET 运行库采用的方法是垃圾回收器，这是一个程序，其目的是清理内存。方法是所有动态请
求的内存都分配到堆上（所有的语言都是这样处理的，但在.NET 中，CLR 维护它自己的托管堆，
供.NET 应用程序使用）。每隔一段时间.当.NET 检测到给定进程的托管堆已满，需要清理时，就调
用垃圾回收器。垃圾回收器处理目前代码中的所有变量，检查对存储在托管堆上的对象的引用，确
定哪些对象可以从代码中访问一 P 哪些对象有引用。没有引用的对象就不再认为可以从代码中访
问.因而被删除。Java 就使用与此类似的垃圾冋收系统。
之所以在.NET 中使用垃圾回收器，是因为中间语言已用来处理进程。其规则要求，第一，不能
弓 I 用己有的对象，除非复制己有的引用。第二，中间语言是类型安全的语言。在这里，其含义是如
果存在对对象的任何引用，该引用中就有足够的信息来确定对象的类型。
垃圾回收机制不能和诸如非托管 C++的语言一起使用,因为 C++允许指针自由地转换数据类型。
垃圾回收的一个重要方面是它的不确定性。换言之，不能保证什么时候会调用垃圾回收器：CLR
决定需要它时，就可以调用它。但可以重写这个过程，在代码中调用垃圾回收器。这在测试时很有
帮助，但是在正常的程序中不应该这么做。
垃圾回收过程的详细信息可参见第 14 章。 3.安全性
.NET 很好地弥补了 Windows 提供的安全机制，因为它提供的安全机制是代码访问安全性（Code
Access Security）,而 Windows 仅提供了基于角色的安全性。
基于角色的安全性建立在运行进程的账户的身份基础上，换言之，就是谁拥有和运行进程。另
一方面，代码访问安全性建立在代码实际执行的任务和代码的可信程度上。由于中间语言提供了强
大的类型安全性，因此 CLR 可以在运行代码前检查它，以确定是否有需要的安全权限。.NET 还提
供了一种机制.使代码可以在运行前，预先指定需要什么安全权限。
基于代码的安全性非常重要，原因是它降低了与运行来历不明的代码有关的风险（如代码是从
Internet 上下载的）。即使代码运行在管理员账户下，也可以使用基于代码的安全性，指定这段代码
不能执行管理员账户一般可以执行的某些类型的操作，例如读写环境变量、读写注册表或访问.NET
反射特性。
安全问题详见第 22 章. 4.应用程序域
应用程序域（application domain）是.NET 中的一个重要技术改进，它用于减少运行应用程序的系统
开销，这些应用程序需要与其他程序分离开来，但仍需要彼此通信。典型的例子是 Web 服务器应用
程序，它需要同时响应许多浏览器请求。因此，要有许多组件实例同时响应这些同吋运行的请求。
在.NET 问世之前，可以让这些实例共享同一•个进程，但此吋一•个运行的实例就有可能导致整个
网站的崩溃：也可以把这些实例孤立在不同的进程中，但这样做会增加相关性能的系统开销。到现
在为止，孤立代码的唯一方式是通过进程来实现的。在启动一个新的应用程序时，它会在一个进程
10

第 1 章.NET 体系结构
坏境内运行。Windows 通过地址窄叫把址枸分隔丌来。这样，姆个进程介 4GB 的虚拟内存来存储其
数椐和 N 执行代艸 4GB 对 hV ]'■ 32 位系统，64 位系统嬰川!II 多的内存）。Windows 利用额外的间接
力式把这雌拟内存映射到物观内存或磁盘空间的•个特殊区域中。梅个进:程都会有不同的映射，
说鵬址空间块映射的物理内.存之间不重桡，如图 I-2 所示。
•般愤况下 I 任何进程都只能通过指定虚:拟内存中的•个地址来访问内一即进程不能直接
物押内 i7. W 此•个进稈不可能 W'H 分 K 给 W •个进柷的内存。这样就可以确保任何执行出错
的代码不会损奔其地:址空间以外的数据。
进杓不仪是运行代码的实例相 h:隔离的•种方式,它们还可以构成分配了安金权限和许可的单
元.每个进程都存 1\*1 己的安全标明确地》Windows 允许该进程可以执行的操作。
进柷对确保安令行很大的栩助，而它们的•大缺点足性能。许多进程常常在一起工作，因此耑
姐相 V 通信。•个常见的例广足进柷调川 个 COM 组件，而该 COM 组件是可执行的，因此芯要
/I:它。己的进祝 I:运行。fl： COM 屮使用代现吋也会发卞类似的情况。因为进程不能共享任何内存,
所以必须使用•个复杂的编组过祝在进程之间复制数据。这对性能有非常大的影响。如果需要使组
fl 起 T 作.们不希嫌縱有损失.唯•的方法是使用基于 DLL 的组件,让所有的组件在同-个地
址空间中运行——其风险是执行 111 错的组件会影响期也組件。
应用 W.域是分離件的•种方式.它不会导致因在进程,之间传送数:裾而产生的性能问题。其
旅坫把任何-个进程分解到多个倚川柷序域中。侮个,应用程序域大翡应--个应用辦，执行的
每个线种部运行在-个 ft 体的掩川利序域中.如阁 1-3 所示。

1\*1 1-2
1’1 描述类 W
醐:4GB 也拟 ⑽
应用程呼域. -个应川 fl!序使川-嗤
也拟内 A
应用积序域:
W -个 hVfflfi!序他用
拟内介

如果不 M 的可执行交件都运什在 M 个进柷空间中,显然它们就能轻松地共卒数据,因为理论
I:它们可以 1'1:接访 M 彼此的数椐，瓜然/I:现论 k 这是可以实现的，1!!.是 CLR 会检査每个正在运行的
醐辦的代码.以确保这些代码不脱离它 n 己的数据区域,保证不发生 n 接访问其讎程的数掘
的怙况。这初矜,起来足不 llj•能的，不典正运行枸序,如何诉程序嬰做什么工作?
实际 I:.这么做通常是 II]•能的.因为屮间语芑拥#强大的类堺安全:功能。fli 大多数悄况下，除
II 代码叫确使用不安全的特性，例如指针,内则它使用的数姻类彻可以确保内存不会被错误地访问。
例如,.NET 数组类划执行边界检 ft.以确保饿 11:执行超 III 边界的数飢视作。如果运行的应用程序的
棚霈败 M 运行在 4 ＜同应用柷序域中的其他醐辦通倌或共数裾，就必须调 IIJ.NET 的远程服务。
被验诎不能访问超 III 其应川种序域的数椐（除 1h 通过明确的远枴处刑机制）的代码就是内存类型安
11

第 I 部分 C#语言
全的代码。这种代码与运行在同一个进程中但应用程序域不同的类型安全代码一起运行是安全的。
1.3.4 通过异常处理错误
.NET Framework 可以与 Java 和 C++＜用相同的基于异常的机制处理错误情况。•开发人员应
注意到，由于 IL 有更严格的强类型系统，因此在 IL 中不像 C++那样存在因使用异常带来的相关性
能问题。另外，.NET 和 C#支持 finally 块，这是许多 C++开发人员长久以来一直希望 C++&能够提
供的一种功能。
第 16 章会详细讨论异常。简要地说，代码的某些部分被看成异常处理例程，每个例程都能处理
某种特殊的错误情况(例如，找不到文件，或拒绝执行某些操作)。这些条件可以定义得很宽或很窄，
异常结构确保在发生错误情况时，执行进程立即函倒最有针对性的异常处理例社，来处理错误情况。
异常处理的结构还提供了一种简便的方式，可以将包含异常情况的准确信息的对象传递给错误
处理例程。这个对象包括给用户提供的相应消息和在代码的什么地方检测到错误的确切消息。
大多数异常处理结构，包括异常发生时的程序流控制，都是由高级语言处理的，例如 C#、Visual
Basic 2013 和 C++,任何中间语言中的命令都不支持它。例如，C#使用 tiy{}、catch{}^ finaUy{}
代码块来处理它，详见第 16 章。
但.NET 提供了一种基础设施，让面向.NET 的编译器支持异常处理。特别是它提供了一组.NET
类来表示异常，语言的互操作性则允许异常处理代码解释被抛出的异常对象，无论异常处理代码使
用什么语言编写，都是这样。语言的无关性没有体现在 C++和 Java 的异常处理中，但在 COM 的错
误处理机制中有一定限度的体现。COM 的错误处理机制包括从方法中返回错误代码以及传递错误
对象。在不同的语言中，异常的处理是一致的，这是促进多语言开发的重要一环。
1.3.5 特性的使用
特性(attribute)是使用 C++编写 COM 组件的开发人员很熟悉的一个功能(在 Microsoft 的 COM 接
口定义语言(Interface Definition Language, IDL)中使用特性)。特性最初是为了在程序中提供与某些
项相关的额外信息，以供编译器使用。
.NET 支持特性，因此现在 C++、C#和 Visual Basic 2013 也支持特性。但在.NET 中，对特性的
革新是可以在源代码中定义自己的自定义特性。这些用户定义的特性将和对应数据类型或方法的元
数据放在一起，这对于文档记录十分有用，它们和反射技术一起使用，以根据特性执行编程任务。
另外，与.NET 的语言无关性的基本原理一样，特性也可以在一种语言的源代码中定义，而被用另一
种语言编写的代码读取。
第 15 章将详细介绍特性.
1.4 程序集
程序集(assembly)是包含编译好的、面向.NET Framework 的代码的逻辑单元。本章不详细论述
程序集，而在第 19 章中论述，下面概述其中的要点。
12

第 1 章.NET 体系结构
程序集是完全自描述性的，它是一个逻辑单元而不是物理单元，可以存储在多个文件中（动态程
序巢存储在内存中，而不是存储在文件中）。如果一个程序集存储在多个文件中，其中就会有一个包
含入口点的主文件，该文件描述了程序集中的其他文件。
可执行代码和库代码使用相同的程序集结构。唯一的区别是可执行的程序集包含一个主程序入
口点.而库程序集不包含。
程序集的一个重要特征是它们包含的元数据描述了对应代码中定义的类型和方法。程序集也包
含描述程序集本身的元数据，这种程序集元数据包含在一个称为“清单（manifest）”的区域中，可以
检查程序集的版本及其完整性。
ildasm 是一个基于 Windows 的实用程序，可以用于检查程序集的内容，包括程序
集清单和元数据.第 19 章将介绍 ildasm。
程序集包含程序的元数据，表示调用给定程序集中的代码的应用程序或其他程序集不需要引用注
册表或其他数据源，就能确定如何使用该程序集。这与以前的 COM 有很大的区别，以前，组件和接
U 的 GUID 必须从注册表中获取，在某些情况下，方法和属性的详细信息也需要从类型库中读取。
把数据分散在 3 个以上的不同位置上，可能会出现信息不同步的情况，从而妨碍其他软件成功
地使用该组件。有了程序集后，就不会发生这种情况，因为所有的元数据都与程序的可执行指令存
储在一起。即使程序集存储在几个文件中，数据也不会出现不同步的问题。这是因为包含程序集入
口的文件也存储了其他文件的细节、散列和内容，如果一个文件被替换，或者被篡改，系统肯定会
检测出来，并拒绝加载程序集。
程序集有两种类型：私有程序集和共享程序集。
1.4.1 私有程序集
私有程序集是最简单的一种程序集类型。私有程序集一般附带在某个软件上，且只能用于该软
件、附带私有程序集的常见情况是.以可执行文件或许多库的方式提供应用程序，这些库包含的代
码只能用于该应用程序。
系统可以保证私有程序集不被其他软件使用,因为应用程序只能加载位于主执行文件所在文件
夹或其+文件夹中的私有程序集。
用户•般会希望把商用软件安装在它自己的目录下，这样软件包不存在覆盖、修改或在无意间
加载另 个软件包的私有程序集的风险。私有程序集只能用于自己的软件包.这样，用户对什么软
件使川它们就有了更大的控制权。因此，不需要采取安全措施，因为这没有其他商用软件用某个新
版本的盖原来的私有程序集的风险（但软件是专门执行怀有恶意的损害性操作的情况除
外）。名称也不会有冲突。如果私有程序巣中的类正巧与另一个人的私有程序集中的类同名，是不会
有问题的.因为给定的应用程序只能使用它自己的一组私哲程序集。
因为私釘程序集是完全包包含的，所以部署它的过程就很简单。只需要把相应的文件放在文件
系统的对应文件夹中即可（不滞嬰注册表项），这个过程称为“0 影响（xcopy）安装”，
1.4.2 共享程序集
共李程序依是其他应用程序可以使用的公共庫。因为其他软件可以访问共享程序集，所以笟耍
13

第丨部分 C#语言
采取一定的保护措施来防止以下风险：
•名称冲突，另一个公司的共享程序銀执行的类型与 G 己的共享程序集中的类型同名。因为
客户端代码理论上可以同吋访问这些程序集，所以这是•个严重的问题。
•程序集被同一个程序集的不同版本蒗盖一版本与某些己有的客户端代码不兼容。
这些问题的解决方法是把共享程序集放在文件系统的•个特定的子冃录树中.称为全局程序圯
缓存（GAC）。与私有程序集不同，不能简单地把共享程序银复制到对应的文件夹中.而耑嬰专门安
装到缓存中，可以用许多.NET 工具完成这个过程.其中包含对程序集的检查、在程序集缓存中设贸
—个小的文件夹层次结构.以确保程序集的完粮性。
为了避免名称冲突，应根据私钥加密法为共卒程序姐指定一个名称（而对于私有程序堪.只耑要
指定与其主文件名相同的名称即可）。该名称称为强名（strong name）.汴保证其唯•性.它必须由要
引用共享程序集的应用程序来引用。
与覆盖程序集的风险相关的问题.可以通过在程序狼淸单中指定版本信息来解决.也可以通过
同时安装来解决。
1.4.3 反射
因为程序集存储了元数据，包括在程序集中定义的所有类型和这些类型的成员的细节.所以可
以编程访问这些元数据。这个技术称为反射，第 15 章详细介绍了它们。该技术很有趣.因为它表
托管代码实际上可以检查其他托管代码，甚至检査它 0 己.以确定该代码的信息。它们常常用于获
取特性的详细信息，也可以把反射用于其他目的.例如作为实例化类或调 m 方法的 种间接方式（前
提是将这些类或方法的名称指定为字符串）。这样，就可以选择类来实例化方法，以便在运行吋调用.
而不是在编译吋调用.例如根据用户的输入来调用（动态绑定 h
1.4.4 并行编程
.NET Framework 允许利用目前出现的所打多核处现器。并行计览能力提供了分隔工作活动、并
在多个处理器上运行这些活动的方式。现在可川的、新的井 ir 编柷 api 使得编 S 安全的多线程代码
变得十分简单.但要注意.仍需耍考虑竞态条件和死锁。
新的并行编程功能提供了 •个新的 Task Parallel Library 和 PLINQ Execution Engine,并 ff 编的
详细内容请参见第 21 章。
1.4.5 异步编程
C# 5.0 以 Task Parallel Library 中的 Task 为基础，提供了新的异步功能，|：|从.NET 1.0 以来,.NET
Framework 中的昨多类都同吋提供了同步和异步版本。当用户界面线柷/E 执行耑耍佗赀•巧时间的
任务吋，是不应该被阻塞的。如果看到过不响应的程序.就会知道那足很烦人的。01 足.异步方法
的缺点是很难使用。对应的同步版本在编'弓程序吋很方便.所以更加常用。
使用了很多年鼠标的用户会习惯延迟。移动对象成行使用滚动条吋.延迟足很常见的。们.是.
对于触摸界面.延迟会造成很糟糕的用广体验。这可以通过调 W 异步方法来解决。M WinRT 中的
某个方法：耍超过 50ms 才能完成，邶么 WinRT 会只提供异步方法调川。
在 C# 5.0 中调川新的异步方法足很简哏的。C# 5.0 定义 f 叫个新的 X；键 7: async 和 await。第
13 章将介绍这两个关键字和它们的川法。
14

第 1 車.NET 体系结构
1.5.NET Framework 类
至少从开发人员的角度来看，编写托管代码的最大好处是可以使用.NET 基类库。.NET 基类是
一个内容丰富的托管代码类集合，它可以完成以前要通过 Windows API 来完成的绝大多数任务。这
些类沿用中间语言使用的对象模型，也基于单一继承性。可以从任何适用的.NET 基类实例化对象，
也可以从它们派生自己的类。
■NET 基类的一个主要优点是它们非常直观和易用。例如，要启动一个线程，可以调用 Thread
类的 Start（）方法。要禁用 TextBox,应把 TextBox 对象的 Enabled 属性设置为 false» Visual Basic 和
Java 开发人员非常熟悉这种方式，它们的库也都很容易使用，但对于 CH■ 开发人员这是极大的解脱，
因为他们多年来一直在使用诸如 GetDIBitsO、RegisterWndClassExO^H lsEqualUD（）这样的 API 函数，
以及大量需要传递 Windows 句柄的函数。
另一方面，C++开发人员总是很容易访问整个 Windows API,而 Visual Basic 6 和 Java 开发人员
只能访问其语言所能访问的基本操作系统功能。.NET 基类的新增内容就是把 Visual Basic 和 Java 库
的易用性和 Windows API 函数较为丰富的功能结合起来。但 Windows 仍有许多功能不能通过基类来
使用，而需要调用 API 函数。但一般情况下，这只限于比较复杂的特性。基类库足以应付日常工作
的使用。如果需要调用 API 函数，.NET 提供了所谓的“平台调用”，来确保对数据类型进行正确的
转换，这样无论是使用 C#、O+或 Visual Basic 2013 进行编码，该任务都不会比直接从己有的 C++
代码中调用函数更困难。
第 3 章主要介绍基类。概述了 C#语言语法后，本书的其余内容将主要说明如何使用.NET
Framework 4.5 的.NET 基类库中的各种类，即各种基类是如何工作的。.NET 4.5 基类大致包括以下
范围：
•IL 提供的核心功能（例如，通用类型系统中的蕋本数据类型，详见第 2 章）
•Windows U1 支持和控件（参见第 35 章~第 39 章）
•在 ASP.NET 中使用 Web 窗体和 MVC（参见第 30 章〜第 42 章）
•使用 ADO.NET 和 XML 进行数据访问（参见第 32 章~第 34 章）
•文件系统和注册表访问（参见第 24 章）
•网络和 Web 浏览（参见第 26 章）
•.NET 特性和反射（参见第 15 章）
•COM 互操作性（参见第 23 章）
附带说一下，根据 Microsoft 源文件，大部分.NET 基类实际上都是用 C#编写的！
1.6 名称空间
名称空间是.NET 避免类名冲突的一种方式。例如，名称空间可以避免下述怙况：定义一个类来
衣示一个顾客，称此类为 Customer,同吋其他人也在做相同的事（很可能出现这种惜况.拥行客户的
企业所占的比例很商）。
名称空间不过足数据类彻的一种组合方式，似名称卞间屮所苻数据类喂的名称部会〔I 动加 I•.该
名称空间的名字作为其前缀,，名称空间还可以相互嵌贫。例如，大多数用 f •般 kl 的的.NET 妯类位
15

第 I 部分 C#语言
于名称空间 System 中，基类 Array 在这个名称空间中，所以其全名是 System,Array。
.NET 需要在名称空间中定义所有的类型，例如，可以把 Customer 类放在名称空间
YburCompanyName.ProjectName 中，贝 ll 这个类的全名就是 YburCompanyName.PrqjectName.Customer0

如果没有显式提供名称空间，类型就添加到一个没有名称的全局名称空间中.
在大多数情况下，Microsoft 建议都至少要提供两个嵌套的名称空间名，第一个是公司名，第二
个是技术名称或软件包的名称，而类是其中的一个成员，例如 YourCompanyName.Sales-
Services.Customer^大多難况下，这么做可以保 K 名殆与其写酿名冲突。
第 2 章将详细介绍名称空间。
1.7 用 C#创建.NET 应用程序
C#可以用于创建控制台应用程序：仅使用文本、运行在 DOS 窗口中的应用程序。在对类库进
行单元测试、创建 UNIX/Linux 守护进程时’就要使用控制台应用程序。但是，我们常使用 C#^J 建
利用许多与.NET 相关的技术的应用程序，下面简要论述可以用 C#创建的不同类型的应用程序，
1.7.1 创建 ASP.NET 应用程序
最初引入的 ASP.NET 1.0 基本改变了 Web 编程模型。ASP.NET 4.5 是该产品的一个主要版
本，它建立在以前改进的基础之上。ASP.NET 4.5 采取了一系列重要的革新步骤来提髙效率。
ASP.NET 的主要目标是使用最少的代码建立强大、安全、动态的应用程序，由于本书是关于 C#
的，所以有许多章节介绍了如何使用这种语言建立最新的 Web 应用程序。
下面讨论 ASP.NET 的重要功能，详细信息参见第 40〜第 42 章。
1.ASP.NET 的功能
ASRNET 最初被设计出来时，只提供了 ASP.NET Web 窗体’其目标是按照 Windows 应用程序开
发人员编写应用程序的方式轻松地创建 Web 应用程序，是不必编写 HTML 和 JavaScript 的。
现在情况发生了变化，HTML 和 JavaScript 重新焕发了生机,再次变得重要起来，相应地,ASRNET
中有了一个新的框架，不只方便了编写 HTML 和 JavaScript,还基于流行的 MVC 模式提供了代码的
分离，从而更便于进行单元测试。这个框架就是 ASP.NETMVC。

重构后的 ASRNET 为 ASRNET Web 窗体和 ASP-NET MVC 打下了基础，而且 UI 框架也构建在
这个基础之上。

第 40 章将介绍 ASP-NET 打下的基站.
16

第 1 章.NET 体系结构
2.ASP.NET Web 窗体
为了简化 Web 页面的结构，Visual Studio 2013 提供了 Web 窗体。它们允许以图形化方式建立
ASP.NET 页面：换言之.就是把控件从工具箱拖放到窗体上，再考虑窗体的代码，为控件编写事件
处理程序。在使用 C#创建 Web 窗体吋，就是创建•个继承 G Page 基类的 C 條，并把这个类看成代
码隐藏的 ASP.NET 页面。当然不是必须使用 C#创建 Web 窗体，也可以使用 Visual Basic 2013 或另一
种.NET 兼容语言来创建。
ASP.NET Web 窗体提供了丰富的功能，使用它的控件不只可以创建简单的代码，还能够利用
JavaScript 和服务器端验证逻辑进行输入验证，以及使用网格和数据源来访问数据库。ASP.NET 的 Web
窗休还提供了 Ajax 功能，允许在客户端动态渲染页面的某个部分，
第 41 章将详细讨论 ASP.NET Web 窗体。
3.Web 服务器控件
用于添加到 Web 窗体 L:的控件与 ActiveX 控件并不是同一种控件，它们是 ASP.NET 名称空间
中的 XML 标记。当请求•个页面吋，Web 浏览器会动态地把它们转换为 HTML 和客户端脚本。
Web 服务器能以不同的方式显示相同的服务器端控件，产生一个对应于请求者特定 Web 浏览器的转
换。这意味珩现在很容易为 Web 页面编勾相当复杂的用户界面.而不必担心如何确保页面运行在可
Jfl 的任何浏览器上，因为 Web 窗体会完成这些任务。
可以使用 C#或 Visual Basic 2013 扩展 Web Form 工具箱。创建一个新服务器端控件只需要实
现.NET 的 System.Web.UI.WebControls.WebControl 类而己。
4.ASP.NET MVC
Visual Studio Ll 带了 ASP.NET MVC 4。这种技术己经发展到第 4 个版本了。Web 窗体采取的做
法是为开发人员抽象掉了 HTML 和 JavaScript,但是随着 HTML5 和 jQuery 的出现，使用这些技术
冉次变得重耍起来。ASP.NET MVC 将重点放到了在模型和控制器中单独编写服务器端代码，而在
使用视图时只用少!it 服务器端代码从控制器屮获収信息。这种功能分离使得编写单元测试变得简单，
并且让开发人员能够充分利用 HTML5 和 JavaScript 厍。
第 42 章介绍了 ASP.NET MVC.
1.7.2 使用 WPF
•ff 两种技术可以川于创 il! Windows 枭而极用程序：Windows 窗体和 Windows Presentation
Foundation(WPF). Windows 窗体包 A 的类只是封装了原 Windows 控件，所以是基于像素阁形的。
WPF 则是坫于矢掛阁的•种新技术。
WPF 在让立应川程序时使用 XAML。XAML 表示可扩展的应用程序标记语言(extensible
17

第 I 部分 C#语言
Application Markup Language)»这种在 Microsoft 环境下创建应用程序的新方式在 2006 年引入，
是.NET Framework 3.0 的一部分。要运行 WPF 应用程序，需要在客户机上至少安装.NET Framework
3.0。当然，更新版本的.NETFramework 会提供新的 WPF 功能。例如，.NET4.5 中新增了功能区控
件和实时造形等功能。
XAML 是用于创建窗体的 XML 声明，它代表 WPF 应用程序的所有可视化部分和操作。虽然
可以编程利用 WPF 应用程序，但 WPF 是迈向声明性编程的一步，而声明性编程是编程业的趋势。
声明性编程是指，不是利用编译语言，如 C#、VB 或 Java,通过编程来创建对象，而是通过 XML
类型的编程来声明所有元素。第 29 章介绍了 XAML(XML Paper Specification、Windows Workflow
Founding 和 Windows Communication Foundation 也使用 了 XAML)。
第 35 章详细介绍了如何使用 XAML 和 C#构建 WPF 应用程序。第 36 章详细介绍了如何使用
WPF 和 XAML 创建数据驱动的业务应用程序。打印和创建文档是 WPF 的另外一个重要方面，第
37 章将进行讨论。
1.7.3Windows Store 应用程序
Windows 8 用“触摸为先”的 Windows Store 应用程序开启了一种新的范式。桌面应用程序通常
会提供一个菜单和一个工具栏，用户在应用程序的一个框架中查看下一步可以做什么。Windows
Store 应用程序则将重点放到了内容。应用程序的框架应该缩减到最低，只提供用户与内容交互所需
的任务，而不是提供他们可以使用的不同选项。关注点应是当前的任务.而不是用户下一步可能要
执行的操作。这样一来，用户就会根据内容记住应用程序的用途。‘‘有内容、无框架"是这种技术的
口号。
可以使用 C#和 XAML,结合 Windows Runtime 和.NET Framework 的一个子集编写 Windows
Store 应用程序。Windows Store 应用程序为开发人员提供了广阔的新世界。其主要缺点是只能运行
在 Windows 8 或更高版本的操作系统上。

第 31、38. 39 章将详细介绍创建 Windows Store 应用程序.
1.7.4Windows 服务
Windows 服务(最初称为 NT 服务)是一个在基于 Windows NT 内核的操作系统上后台运行的程
序。当希望程序连续运行，并在用户没有明确启动操作吋响应事件，就应使用 Windows 服务。例如
Web 服务器上的 World Wide Web 服务，它们监听来自客户端的 Web 请求。
用 C#编写服务非常简单。System.ServiceProcess 名称空间中的.NETFramework 基类可以处理许
多与服务相关的样本任务。另外，Visual Studio .NET 允许创建 C# Windows Service 项目，为基本
Windows 服务编写 C#源代码。第 27 章将详细介绍如何编写 C# Windows 服务。
1.7.5WCF
ASP.NET Web API 可以实现客户端和服务器之间的通信，它使用起来十分简单，但是功能不如
SOAP 协议丰富。
WCF 是一种功能丰富的技术，提供了多种通信选项。使用 WCF 吋，既可以使用基于 REST 的
18

第 1 章.NET 体系结构
通信，也可以使用基于 SOAP 的通信，都能获得标准 Web 服务（如安全性、事务、双向和单向通信、
路由、发现等）提供的所存功能。WCF 允许建立好服务后，只要修改配置文件，就可以用多种方式
提供该服务（甚至在不同的协议下）。WCF 是一种连接各种系统的强大的新方式。第 43 章将详细介
绍 WCF。第 47 章也会讲到一些基于 WCF 的技术，例如 Message Queueing with WCF。
ASP.NET Web API
ASP.NET Web API 是在客户端和服务器之间进行简单通信的-种新方式（REST 风格）。这种新框
架基于 ASP.NET MVC.并使用了控制器和路由。客户端可以收到符合开放数据（Open Data）规范的
JSON 或 Atom 数据。
这个新 API 具备的-些特征使得不只 Web 客户端很容易在 JavaScript 中使用它,而且在 Windows
Store 应用程序中也很容易使用。
]

ASP.NET Web API 在第 44 章中介绍
1.7.6Windows WF
Windows Workflow Foundation（WF）实际上是在.NET Framework 3.0 中引入的，但经过全面修订，
自从.NET 4 以外许多人邡发现它更容易使用了 ..NET 4.5 也对它做了一点小改进。Visual Studio 2013
在使用 WF 方面有了氏足的进步，并使得使用 C#（原来的版本使用 VB）构建工作流和编写表达式变
得更简单。WF 有-个新的状态机设计器和一些新活动。
（^） 第 45 章将详细讨论 WF. |
1.8C#在.NET 企业体系结构中的作用
新技术总在快速出现。应该为企业应用程序使用哪种技术呢？有汴多因素影响着所耍做出的决
定。例如，如果现打闲用柷序是开发人员根裾现有知识开发的，应该怎么办？可以在遗留应用程序
中集成新功能吗?根据需要的维护镦,可能重新构建一些现:有的应用程序来使用新功能更加合理。
通常，遗留应用程序和新应用程序是可以共存很长•段吋间的。应用辦对客户端有什么需求?需
嬰把.NET Framework 升级到 4.5 版本吗？还是 2.0 版本就够了？或者，客户端能够使 ffl.NET 吗？
耍做的决定很多..NET 也提供了很多选项。可以在客户端的 Windows 窗休、WPF 或 Windows
8 hV 川彻 i■:屮使川.NET.也 nJ■ 以在使川 IIS 和 ASP.NET 运行庳托管的 Web 服务器 t 的 ASP.NET Web
窗体成 ASP.NET MVC 屮使 ffl.NET。服务可以运行在 IIS 内，也可以托符在 Windows 服务内-C#
为希帘 51 立稳健的 n 历客户机/服务器用程序的公司提供了 •个最佳的机会。
C#Fj ADO.NET 介并后，就呵以快速而经常地访问数损存储库了，如 SQLSe^er 和其他带存数
枞提供种印的数枞库，使川 ADO.NET Entity Framework 很矜易将数掘痄关系映射为对象层次结构。
这不只迅川 P SQL Server.也 ifi 用'•多提供 f Entity Framework 提供 ft!序的数枢 IV。返网的
19

第 1 部分 C#语官
数据集很容易通过 ADO.NET 对象模型或 LINQ 来处理，并自动显示为 XML 或 JS0N，以便通
过办公室内联网来传输。
—旦为新项目建立了数据库模式，C#就会为执行一层数据访问对象提供一个极好的媒介，每个
对象都能提供对不同数据库表的插入、更新和删除访问。
因为 C#是第一个基于组件的 C 语言，所以非常适合于执行业务对象层。它为组件之间的通信
封装了杂乱的信息，让开发人员把注意力集中在如何把数据访问对象组合在一起，在方法中精确地
强制执行公司的业务规则。
要使用 CT&J 建企业应用程序，可以为数据访问对象创建一个类库项目，为业务对象创建另一个
类库项目。在开发时，可以使用 Console 项目测试类上的方法。喜欢编程的人可以建立能自动从批
处理文件中执行的 Console 项目，对工作代码进行单元测试，以便确定代码是否中断。
注意，C#和.NET 都会影响物理封装可重用类的方式。过去，许多开发人员把许多类放在一个
物理组件中，因为这样安排会使部署容易得多：如果有版本冲突问题，就知道在何处进行检査。因
为部署.NET 企业组件仅是把文件复制到目录中，所以现在开发人员可以把他们的类封装到逻辑性更
髙的离散组件中，而不会遇到“DLLHell\
最后，用《写的 ASP.NET 页面构成了用户界面的绝妙媒介。ASP.NET 页面是编译过的，所
以执行得比较快。它们可以在 Visual Studio 2013 IDE 中调试，所以十分健壮。它们支持所有的语言
功能，例如早期绑定、继承和模块化，所以用 ⑽ 写的 ASPNET 页面是很整洁的，很容易维护。
在 SOA 和基于服务的编程热潮过后，现在使用服务己经成为了一种业界常规。新的趋势是基
于云的编程，Microsoft 为此提供了训 ndowsAzure。可以在本地服务器或者云中的 ASP.NETWeb 窗
体、ASPNETl^bAPI 或 WCF 中运行.NET 应用程序。客户端则可以使用来接触更多的受
众，或者使用 WPF 或 Windows Store 应用程序来实现丰富的功能。.NET 仍然能够跟得上新技术，
利用新选项，所以生机是无限的。
1.9 小结
本章介绍了许多基础知识，简要回顾了.NET Framework 的重要方面以及它与 C#的关系。首先
讨论了所有面向的语言如何编译为中间语言（之后由公共语言运行库进行编译和执行），接着讨
论了.NET 的下述特性在编译和执行过程中的作用：
•程序集和.NET 基类
•COM 组件
•JIT 编译
•应用程序域
•垃圾回收
图 1-4 简要说明了这些特性在编译和执行过程中如何发挥作用。
本章还讨论了 IL 的特征，特别是其强数据类型化和面向对象的特征。探讨了这些特征如何影响
面向.NET（包括 C#）的语言，并阐述了 IL 的强类型本质如何支持语言的互操作性，以及 CLR 服务，
如垃圾回收和安全性，还讨论了用于帮助处理语言互操作性的 CLS 和 CTS.
